# 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다

> 데이터의 원천이 하나여야 한다는 뜻입니다. 더 알아봅시다!

데이터는 두 가지 형태로 제공되곤 한다.

- 기본 데이터  
   코드의 동작에 꼭 필요한 데이터
  > ex) 곱하기 함수는 두 수가 없으면 동작할 수 없죠
- 파생 데이터  
  기본 데이터에서 계산할 수 있는 데이터

  > ex) 이름의 길이를 검증하는 함수가 있다고 해봅시다.  
  > 이름 길이는 이름만 있으면 구할 수 있으므로, 길이를 `int`로 넘길 필요가 전혀 없습니다.
  >
  > ```java
  > void validateLengthOf(String name) {
  >   if (name.length() > 10) {
  >       throw new IllegalArugmentException("이름이 너무 길어요!!");
  >   }
  > }
  > ```

- 은행 예시  
   은행 계좌의 상태를 설명한다고 합시다.  
   `예금`과 `채무`, 두 가지 기본 데이터로 `잔액` 이라는 파생 데이터를 알 수 있습니다.
  > 책에서 대변(💩 아닙니다)과 차변이라는 말을 사용하는데 이해하기 쉽게 바꿔보았습니다.  
  >  뜻은 정확히 일치하지 않을 수 있어요.

이렇게 기본 데이터는 프로그램에서 '진실의 원천'이 됩니다.

# 7.5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다

> ![image](https://user-images.githubusercontent.com/39221443/226126308-7b95ccd7-a1fa-416b-9599-65070f8f1cd7.png)

이 코드에서 파생 데이터 `잔액`은 기본 데이터 `예금`과 `채무` 두 가지 외에 따로 관리되고 있어요.  
따라서 `잔액`이 잘못된 상태로 저장되는 경우가 생길 수 있습니다.

> ```java
> UserAccount userAccount = new UserAccount(credit, debit, debit - credit);
> ```

`예금`에서 `채무`를 빼야 정확한 `잔액`이 나오는데, 반대로 하였습니다.  
이 경우 논리적으로 잘못된 객체가 되겠죠?  
이렇게 실수의 가능성이 있기 때문에 '진실의 원천'을 하나로 관리해야 합니다.

# 7.5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라
> ![image](https://user-images.githubusercontent.com/39221443/226127123-92cee431-a362-44e1-a326-967443606759.png)

문제의 가능성을 제거한 코드입니다.

## 데이터 계산에 비용이 많이 드는 경우
예제는 단순한 계산이기 때문에 비용이 거의 들지 않았죠.  
그러나 때로는 파생 데이터를 계산하는데 비용이 꽤나 비쌀 수 있습니다.  
예금과 채무가 아니라, **입출금 내역**이라고 해볼까요?  
> 책에서는 **입출금 내역**을 트랜잭션이라고 표현하고 있습니다.

여기서 파생 데이터를 계산하려면 모든 내역을 뒤져야 하기 때문에 꽤 비싸겠죠?  
하지만 다 방법이 있습니다.

### 지연 계산 & 캐싱
>![image](https://user-images.githubusercontent.com/39221443/226128735-d1fde6ac-45b4-40e7-a9da-eb8affe7ff48.png)
>![image](https://user-images.githubusercontent.com/39221443/226128812-d486e313-956f-4f19-bcb2-8d75131420ac.png)

파생 데이터 계산 비용이 비싸다면, 지연 계산한 후에 캐싱하는 것이 좋습니다. 한 번만 계산하기 때문이죠.  
하지만 의심해야 합니다. **입출금 내역**이 바뀌면 어떡하죠?  
`cachedDebit`, `cachedCredit`은 새로운 '진실의 원천'이 된 것이 아닐까요?  

예제의 경우 "**입출금 내역**은 변하지 않는다"고 가정하고 있기 때문에 괜찮습니다.  
하지만 불변이 아니라면, 매번 **캐시를 널로 초기화**하고, **널 체크**도 해주어야 하므로 오류 가능성이 커지겠죠?  
이런 면에서 불변 객체는 리소스 관리만 잘 된다면 다루기 좋고, 안전한 것 같습니다.